---
tags:
  - intro-models
  - non-relational-data
  - unstructured-data
  - cbd
aliases:
  - non-relational
---
---
[[Complementi di Basi di Dati | <- Go to index]]
# Introduction

Generally speaking, we know how to work with **structured and relational data** and [its management systems](https://www.notion.so/hyspxt/Basi-di-Dati-9-CFU-3ab24755a0a34f2eafb102b2c03d67cf) (*SQL, ER diagrams, etc*). However, today we produce massive amounts of <b style="color: red;">non-relational and semi-structured data</b>, which properties substantially differs from the structured counterpart. 
Here, we will study methods to handle it.

> [!EXAMPLE]
> 
> Examples of **unstructured** data are images, videos and documents.
> *Structured* (with a [[Schema|schema]]!):
> 
> |  id   |   name  | surname |
| --- | --- | --- |
|   01  |  Bob    | Ross |
|   02  |  Jane    | Doe |

Unstructured data require specific processing (e.g., analysis algorithms). In particular, **Information Retrieval** is how we call the study of schema-less data. Classical [[DBMS]] struggle to handle unstructured data, but newer introduced:
- **BLOB** (*Binary Large Object*) -> a field (column) that can contain large binary data. Typical use case are <u>images</u> and <u>audio</u>. DBMS treat such fields as a byte sequence, **without semantic interpretation** nor knowing their format (a blob).
- **CLOB** (*Character Large Object*) -> same, but with text. Used for long text and articles. DBMS can *index* or manipulate them through functions.
Query in this area are simple and **classification-based** (*e.g., <mark style="background: #BBFABBA6;">"Return documents that contains the word 'pippo'"</mark>*). Then, no manipulation is intended, but rather **selection** and **sorting by relevance**.


# Semi-structured data

First, let's recall the particularities of **structured** / relational data:
- **Boolean model** based on the 'set' concept: the tuple returning from a <u>query is present or is not present</u>. 
- Unordered and not nested. Plus, a **clear distinction** between data and [[Schema]].
- **Query language** oriented to 'requirements' (e.g., "Return only person with $Age >50$).
Moreover, it has a fixed structure -> if we want to modify the data, we need to modify the schema and communicate to all applications that uses it.


Now, <mark style="background: #FFB86CA6;">semi-structured data</mark> shows both structured and unstructured properties:
- Schema is present, but it is irregular, partial and **it evolves** (built a posteriori).
- Data are represented by **lists** instead of sets, which can be **ordered** and **nested**.
- Accept SQL as query language, but is generally more inefficient.
