---
tags:
  - xml
  - sql
  - relational-data
aliases:
  - sql-to-xml
---
---
# Using XML/SQL

As we saw, XML is used primarily for **data exchange** between applications and **representation of semi-structured data**. But, as today, the majority of data is locally stored in relational form. Then, we need a 'bridge': <b style="color:red">SQL/XML</b>, a SQL extension.
Fundamentally, we can:
- **Extract XML** from one or more relational tables (SQL->XML).
- **Store XML** in one or more relational tables (XML->SQL).
The first option is simpler, as XML can represent both structured and semi-structured data, but it isn't as simple as that for the second.

![[venn_semi.png]]

## SQL->XML

This is a simple process, but we can accomplish it in two more ways.
### Through mapping

> [!INFO] Mapping - SQL->XML
> We start from a relational table: `Employees`.
> 
> |id|name|surname|salary|
|---|---|---|---|
|01|Bob|Ross|2000|
|02|Jane|Doe|3000|
> 
>The mapping works as follow:
>- Table's name becomes the name of the XML Document.
> - Each row wil be included in a *\<row>* element and each column value becomes the element content.
> - Null values are represented with the attribute `xsi:nil="true"`.
> ![[sql_mapping.png]]
> Moreover, we can extract specific data using [[2.3 XQuery|XQuery]]:
![[xquery_salaries.png]]
>Then, we will obtain the following view:
>![[highSalaries.png]]
>

### Through extracting XML from a table

>[!INFO] 
>We start from the same table [[#Through mapping|as the previous example]]. We write an SQL query to obtain the same data, smth like:
>```sql
>SELECT i.name AS employeeName
>FROM EMPLOYEES i WHERE i.salary > 2500
>-- Then, we use the obtained table and add an XML constructor through SQL/XML extension:
>SELECT XMLELEMENT(NAME "emp", i.name) AS employeeName
>FROM EMPLOYEES i WHERE i.salary > 2500
>```
>In this way we are extracting tables which contain XML code! Further we will cover more the SQL/XML extension.

## XML -> SQL

The difficult one. Two main modes:
- We consider an XML document as a type of SQL data. Then, we reserve an **object-relational** column of a table for the entire document.
- Through a mapping definition the XML document is "**shredded**" (*with limitations*) in fragments and stored in different fields of a table. The process is basically going [[sql_mapping.png|from this]] into [[#Through mapping|the table]], through a mapping file.


# SQL/XML Language

An extension that support XML in a SQL db: it helps us to **extract XML**. Syntax:
```sql
SELECT Attr1, Attr2, ..., Constructor XML
FROM ... WHERE ...
-- mind that first the XML code is built for each tuple after the view creation through the SQL query!
```

Here we have some operators:
>[!hint] XMLELEMENT
> Allows to **create** an XML element, taking its **name**, an optional **list of attributes** and its **content**.
> ![[XMLELEMENT.png]]
> Mind that `XMLELEMENT` can contain other `XMLELEMENT` too to create children of father tags!

>[!hint] XMLATTRIBUTES
> Used to **declare attributes** of elements. Each parameter (if not declared) takes the name from the column of the table.
> ![[XMLATTRIBUTES.png]]
> This produces a tuple like:
> 
>|  id   |   result  |
| --- | --- |
|   emp01  |  \<emp sal='2000'>Bob Ross\</emp>     |

>[!hint] XMLFOREST
> Rapidly produces a list of simple elements.
> ![[XMLFOREST.png]]
> 
>|  id   |   result  |
| --- | --- |
|   emp01  |  \<emp> \<name>**Bob**\</name> \<co>**Ross**\</co> \<dip>**Sales**\<\dip>\</emp>     |

>[!hint] XMLCONCAT
> Concat its arguments, producing a forest. Supports `XMLELEMENT`.
> ![[XMLCONCAT.png]]
> Notice how the `NAME "emp"` is missing!


>[!hint] XMLAGG
> Group some tuples using `GROUP BY`.
> ![[XMLAGG.png]]
> Notice how the `NAME "emp"` is missing!